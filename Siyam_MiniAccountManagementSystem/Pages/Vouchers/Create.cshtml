@page
@model Siyam_MiniAccountManagementSystem.Pages.Vouchers.CreateModel
@{
    ViewData["Title"] = "Create Voucher";
}

<h1>Create @Model.Voucher.VoucherType Voucher</h1>

<form method="post">
    <div asp-validation-summary="ModelOnly" class="text-danger"></div>
    <div class="form-group m-2">
        <label asp-for="Voucher.VoucherDate"><b>Voucher Date</b></label>
        <input asp-for="Voucher.VoucherDate" class="form-control" type="date" />
        <span asp-validation-for="Voucher.VoucherDate" class="text-danger"></span>
    </div>
    <div class="form-group m-2">
        <label asp-for="Voucher.ReferenceNo"><b>Reference No.</b></label>
        <input asp-for="Voucher.ReferenceNo" class="form-control" />
        <span asp-validation-for="Voucher.ReferenceNo" class="text-danger"></span>
    </div>
    <div class="form-group m-2">
        <label asp-for="Voucher.Narration"><b>Description</b></label>
        <textarea asp-for="Voucher.Narration" class="form-control"></textarea>
        <span asp-validation-for="Voucher.Narration" class="text-danger"></span>
    </div>

    <input type="hidden" asp-for="Voucher.VoucherType" />

    <h3>Voucher Details</h3>
    <tr>
        <td colspan="4">
            <button type="button" class="btn btn-success mt-2" id="addDetailRow">Add New Row</button>
        </td>
    </tr>
    <table class="table table-bordered table-striped text-center mt-2" id="voucherDetailsTable">
        <thead class="bg-info text-white">
            <tr>
                <th>Account</th>
                <th>Debit</th>
                <th>Credit</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody class="bg-light">
            @* Render existing details if Model.Voucher.Details is populated (e.g., after a POST with validation errors) *@
            @if (Model.Voucher.Details != null && Model.Voucher.Details.Any())
            {
                @for (int i = 0; i < Model.Voucher.Details.Count; i++)
                {
                    <partial name="_VoucherDetailRowPartial" model="Model.Voucher.Details[i]"
                             view-data='new ViewDataDictionary(ViewData) { { "AccountList", Model.AccountList }, { "Index", i } }' />
                }
            }
            @* If no existing details, JavaScript will add the first row on page load *@
        </tbody>
        <tfoot>
            <tr>
                <td colspan="1">Total:</td>
                <td><span id="totalDebitDisplay">0.00</span></td>
                <td><span id="totalCreditDisplay">0.00</span></td>
                <td></td>
            </tr>
        </tfoot>
    </table>

    <input type="hidden" asp-for="Voucher.TotalDebit" id="Voucher_TotalDebit_Hidden" />
    <input type="hidden" asp-for="Voucher.TotalCredit" id="Voucher_TotalCredit_Hidden" />

    <button type="submit" class="btn btn-primary">Save Voucher</button>
    <a asp-page="./Index" class="btn btn-secondary float-end">Back to List</a>
</form>

@section Scripts {
    @{
        await Html.RenderPartialAsync("_ValidationScriptsPartial");
    }
    <script>
        // Safely get account options for JavaScript. Using .ToList() ensures it's materialized.
        var accountOptions = @Html.Raw(Json.Serialize(Model.AccountList.Select(x => new { value = x.Value, text = x.Text }).ToList()));

        // Tracks the next available index for new detail rows
        let detailIndex = 0;

        function addVoucherDetailRow(index, detail = { accountId: 0, debit: 0, credit: 0 }) {
            var tableBody = $('#voucherDetailsTable tbody');
            // Ensure the generated HTML is valid and handles values correctly
            var newRowHtml = `
                <tr>
                    <td>
                        <select name="Voucher.Details[${index}].AccountId" class="form-control account-select">
                            <option value="">-- Select Account --</option>
                            ${accountOptions.map(opt => `<option value="${opt.value}" ${opt.value == detail.accountId ? 'selected' : ''}>${opt.text}</option>`).join('')}
                        </select>
                        <span data-valmsg-for="Voucher.Details[${index}].AccountId" class="text-danger"></span>
                    </td>
                    <td>
                        <input type="number" step="0.01" name="Voucher.Details[${index}].Debit" value="${detail.debit.toFixed(2)}" class="form-control debit-input" />
                        <span data-valmsg-for="Voucher.Details[${index}].Debit" class="text-danger"></span>
                    </td>
                    <td>
                        <input type="number" step="0.01" name="Voucher.Details[${index}].Credit" value="${detail.credit.toFixed(2)}" class="form-control credit-input" />
                        <span data-valmsg-for="Voucher.Details[${index}].Credit" class="text-danger"></span>
                    </td>
                    <td>
                        <button type="button" class="btn btn-danger remove-detail-row">Remove</button>
                    </td>
                </tr>
            `;
            tableBody.append(newRowHtml);

            // Re-parse validation for newly added elements
            // Crucial for enabling client-side validation on dynamic rows
            $('form').data('validator', null); // Clear previous validator instance
            $.validator.unobtrusive.parse($('form')); // Re-parse the entire form

            updateTotals();
        }

        function updateTotals() {
            let totalDebit = 0;
            let totalCredit = 0;

            $('.debit-input').each(function() {
                // Use parseFloat and ensure it's not NaN for calculation
                totalDebit += parseFloat($(this).val() || 0) || 0;
            });

            $('.credit-input').each(function() {
                // Use parseFloat and ensure it's not NaN for calculation
                totalCredit += parseFloat($(this).val() || 0) || 0;
            });

            // Update the displayed totals
            $('#totalDebitDisplay').text(totalDebit.toFixed(2));
            $('#totalCreditDisplay').text(totalCredit.toFixed(2));

            // Update the hidden input fields to send values to the server
            $('#Voucher_TotalDebit_Hidden').val(totalDebit.toFixed(2));
            $('#Voucher_TotalCredit_Hidden').val(totalCredit.toFixed(2));
        }

        $(document).ready(function () {
            // Initialize detailIndex based on existing rows from the model if they were rendered
            detailIndex = $('#voucherDetailsTable tbody tr').length;

            // Add an initial empty row only if no details were rendered from the model
            if (detailIndex === 0) {
                addVoucherDetailRow(detailIndex++);
            } else {
                // If details exist (e.g., after a validation error), ensure totals are calculated on load
                updateTotals();
            }

            // Click handler for adding a new detail row
            $('#addDetailRow').click(function () {
                addVoucherDetailRow(detailIndex++);
            });

            // Click handler for removing a detail row (event delegation)
            $(document).on('click', '.remove-detail-row', function () {
                $(this).closest('tr').remove();
                updateTotals();

                // Re-index rows after removal (IMPORTANT for model binding)
                $('#voucherDetailsTable tbody tr').each(function(i) {
                    $(this).find('input, select, span[data-valmsg-for]').each(function() {
                        var name = $(this).attr('name') || $(this).attr('data-valmsg-for');
                        if (name) {
                            // Update name attribute (e.g., Voucher.Details[0].AccountId)
                            $(this).attr('name', name.replace(/\[\d+\]/, '[' + i + ']'));
                            // Update data-valmsg-for attribute for validation messages
                            $(this).attr('data-valmsg-for', name.replace(/\[\d+\]/, '[' + i + ']'));
                            // Update id attribute if it exists, for consistency (optional but good practice)
                            var id = $(this).attr('id');
                            if (id) {
                                $(this).attr('id', id.replace(/_\d+__/, '_' + i + '__'));
                            }
                        }
                    });
                });
                detailIndex = $('#voucherDetailsTable tbody tr').length; // Update the overall index

                // Re-parse validation after re-indexing
                $('form').data('validator', null);
                $.validator.unobtrusive.parse($('form'));
            });

            // Event handler for Debit input: if debit > 0, set credit to 0
            $(document).on('input', '.debit-input', function() {
                const debitValue = parseFloat($(this).val());
                if (debitValue > 0) {
                    $(this).closest('tr').find('.credit-input').val('0.00'); // Set to '0.00' to clear clearly
                }
                updateTotals();
            });

            // Event handler for Credit input: if credit > 0, set debit to 0
            $(document).on('input', '.credit-input', function() {
                const creditValue = parseFloat($(this).val());
                if (creditValue > 0) {
                    $(this).closest('tr').find('.debit-input').val('0.00'); // Set to '0.00' to clear clearly
                }
                updateTotals();
            });

            // Recalculate totals on page load to reflect any pre-filled or validation-re-rendered data
            updateTotals();
        });
    </script>
}